import numpy as np
import matplotlib.pylab as plt
import sys, time
from tqdm import tqdm

"""
This file contains different versions of some of the functions found in NAtoms.py, where
these functions builds on methods where only two time steps of the simulations are kept in memory
at the same time. The data is instead written to text files.
"""

def simulate_sparse(r0, v0, m, T, dt, intg, filename):

    """ A function for simulating the N-atom model with an integration method of choice. Same as simulate(),
    but doesn't store positions and velocities in arrays, but writes them to file instead.

    Args:
        r0: Array with the initial condition for positions.
        v0: Array with the initial condition for velocities.
        m: mass of the atoms
        T: The end time where the integration will stop.
        dt: Size of the time step.
        intg: String telling what method to use; either 'Euler', 'EulerCromer' og 'VelVerlet'.
        filename: Name of the file the data will be written to. Needs an extension like ".xyz".

    returns:
        t: Array for the discrete time points.
    """

    nt = int(T/dt) + 1   # Number of timesteps
    t = np.linspace(0, T, nt)

    N = int(r0.shape[0]/3)

    r = r0
    v = v0

    infile = open(filename, 'w')
    infile.write("%i\n\n" %(N))

    for j in range(N):
        infile.write(str(r[3*j: 3*j +3])[1:-1] + " " + str(v[3*j : 3*j +3])[1:-1] + "\n")

    t_start = time.clock()

    # Time integration
    for i in tqdm(range(nt-1)):

        infile.write("%i\n\n" %(N))

        if intg == 'VelVerlet' and i != 0:
            a = a_next

        else:

            F = np.zeros(3*N)

            for j in range(N):
                for k in range(j+1, N):
                    d_vec = r[3*j: 3*j+3] - r[3*k: 3*k+3]
                    d = np.sqrt(np.sum((d_vec)**2))

                    F_jk = LJ_force(d)*d_vec/d
                    F[3*j: 3*j+3] += F_jk
                    F[3*k: 3*k+3] -= F_jk

            a = F/m

        if intg == 'Euler':
            v_next = v + a*dt
            r_next = r + v*dt

            # Reflective boundary conditions
            out = ((L < r_next) + (r_next < 0))*1
            out[out==1] = -1
            out[out==0] = 1
            v_next = v_next*out
            #r_next = r + v_next*dt

        elif intg == 'EulerCromer':
            v_next = v + a*dt
            r_next = r + v_next*dt

            # Reflective boundary conditions
            out = ((L < r_next) + (r_next < 0))*1
            out[out==1] = -1
            out[out==0] = 1
            v_next = v_next*out
            #r_next = r + v_next*dt

        elif intg == 'VelVerlet':
            r_next = r + v*dt + 0.5*a*dt**2

            F_next = np.zeros(3*N)

            for j in range(N):
                for k in range(j+1, N):
                    d_vec = r_next[3*j: 3*j+3] - r_next[3*k: 3*k+3]
                    d = np.sqrt(np.sum((d_vec)**2))

                    F_jk = LJ_force(d)*d_vec/d
                    F_next[3*j: 3*j+3] += F_jk
                    F_next[3*k: 3*k+3] -= F_jk

            a_next = F_next/m

            v_next = v + 0.5*(a + a_next)*dt

            # Reflective boundary conditions
            out = ((L < r_next) + (r_next < 0))*1
            out[out==1] = -1
            out[out==0] = 1
            v_next = v_next*out
            #r_next = r + v_next*dt

        else:
            print('Error: The variable intg must either be "Euler", "EulerCromer" or "VelVerlet".\nExiting...')
            sys.exit(0)

        for j in range(N):
            infile.write(str(r_next[3*j : 3*j +3])[1:-1] + " " + str(v_next[3*j : 3*j +3])[1:-1]+ "\n")

        r = r_next
        v = v_next

    infile.close()

    t_stop = time.clock()
    print("Tot. simulation time: %.3f s" % (t_stop - t_start))
    print("Time pr iter: %.3f s" % ((t_stop - t_start)/(nt-1)))

    return t

def Energy_sparse(N, t, m, filename, plot = True):
    """ Calculate both the kinetic and potential energies of the N-atom model, reads positions
    and velocities from file generated by simulate_sparse().

    Args:
        N: Number of atoms
        t: Array for the discrete time points.
        m: Mass of the atoms.
        filename: Name of the file to read data from. Assumes that the file has the form:
            ----------------------------------
            <No. atoms>

            <r_1x r_1y r_1z v_1x v_1y v_1z>   # Positions and velocities of atom 1
            ...
            <r_Nx r_Ny r_Nz v_Nx v_Ny v_Nz>   # Positions and velocities of atom N
            ----------------------------------
            This snippet repeats for all time steps.
        plot: Boolean expression, whether to plot the results or not, 'True' as default.

    Returns:
        KinEng: Array for the kinetic energy at each timestep.
        PotEng: Array for the potential energy at each timestep.
    """
    from itertools import islice


    nt = t.shape[0]
    KinEng = np.zeros(nt)
    PotEng = np.zeros(nt)

    #infile = open(filename, 'r')
    with open(filename, 'r') as infile:
        for i in range(nt):
            r = np.empty(0)
            line_gen = islice(infile, 2, N+2)
            j = 0
            for line in line_gen:
                tmp = np.array(line.split(), dtype=np.float)
                r = np.concatenate((r, tmp[:3]))
                v = tmp[3:]

                KinEng[i] += 0.5*m*np.sum(v**2)

                for k in range(j):
                    d_vec = r[3*j : 3*j +3] - r[3*k : 3*k + 3]
                    d = np.sqrt(np.sum(d_vec**2))

                    PotEng[i] += LJ_pot(d)

                j += 1

    if plot:
        fig, (ax1, ax2) = plt.subplots(2, 1)
        ax1.set_title("Kinetic and Potential energy of the " + str(N) + "-atom system")
        ax1.plot(t, KinEng)
        #ax1.set_ylim([-1, 3])
        ax1.set_xlabel(r"$t$")
        ax1.set_ylabel(r"$K(t)$")
        ax1.grid(True)
        ax2.plot(t, PotEng)
        #ax2.set_ylim([-3, 3])
        ax2.set_xlabel(r"$t$")
        ax2.set_ylabel(r"$U(t)$")
        ax2.grid(True)
        plt.show()

    return KinEng, PotEng
